import numpy as np
import pandas as pd
import seaborn as sns
import os
import time
import pickle
import matplotlib.pyplot as plt
from collections import Counter
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier
from sklearn.tree import DecisionTreeClassifier
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix, pair_confusion_matrix
from sklearn.metrics import f1_score, precision_recall_curve, recall_score, roc_curve, precision_score
import warnings
from sklearn.exceptions import ConvergenceWarning
warnings.filterwarnings("ignore", category=UserWarning)
warnings.filterwarnings("ignore", category=FutureWarning)
warnings.filterwarnings("ignore", category=ConvergenceWarning)

import re
from androguard.core.bytecodes.apk import APK
from androguard.core.bytecodes.dvm import DalvikVMFormat
from androguard.misc import AnalyzeAPK

import matplotlib.pyplot as plt

data = pd.read_csv("D:/Study/HK2 2023_2024/BTL Python/Detec/sorted_data.csv", encoding="utf-8", low_memory=False, na_values="?")
data.head()

feature_df = pd.read_csv("D:/Study/HK2 2023_2024/BTL Python/Detec/dataset-features-categories.csv", header=None, names=["X", "Category"])
feature_df.head()

# Tiền xử lý
data["class"] = data["class"].map({"B": 0, "S": 1})
data.head()
data = data.dropna()
plt.figure()
ax = sns.countplot(data=data, x="class")
for container in ax.containers:
    ax.bar_label(container)
plt.show()

X = data.drop("class", axis=1)
y = data["class"]

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

rf = RandomForestClassifier()
start = time.time()
rf.fit(X_train, y_train)
end = time.time()
rf_time = end - start
print("Random Forest Train Time:", rf_time)

rf_pred_train = rf.predict(X_train)
rf_pred_test = rf.predict(X_test)

rf_train_score = accuracy_score(rf_pred_train, y_train)
rf_test_score = accuracy_score(rf_pred_test, y_test)
print("Random Forest Train Score:", rf_train_score)
print("Random Forest Test Score:", rf_test_score)

rf_precision_score = precision_score(y_test, rf_pred_test)
rf_f1_score = f1_score(y_test, rf_pred_test)
rf_recall_score = recall_score(y_test, rf_pred_test)
rf_accuracy_score = accuracy_score(y_test, rf_pred_test)

print("Random Forest Precision Score:", rf_precision_score)
print("Random Forest F1 Score:", rf_f1_score)
print("Random Forest Recall Score:", rf_recall_score)
print("Random Forest Accuracy Score:", rf_accuracy_score)



permissions_list = feature_df[feature_df["Category"] == "Manifest Permission"].X.unique()
api_call_signatures = feature_df[feature_df["Category"] == "API call signature"].X.unique()
intents = feature_df[feature_df["Category"] == "Intent"].X.unique()
keywords = feature_df[feature_df["Category"] == "Commands signature"].X.unique()

columns = ["filename"]
for col in data.columns:
    columns.append(col)
    
test_df = pd.DataFrame(columns=columns)

apk_file_path = "D:/Study/HK2 2023_2024/BTL Python/Detec/APK/F6CF794259EC3177C63C4BE132E80C79FB7929842CDF83E3ED74F491D51BEFA7.apk"

test_df.loc[0, "filename"] = apk_file_path

test_df.head()

a = APK(apk_file_path)
d = DalvikVMFormat(a.get_dex())

permissions = a.get_permissions()
manifest = a.get_android_manifest_xml()
intent_filters = manifest.findall(".//intent-filter")

found_permissions = []
found_api_signatures = []
found_intents = []
found_keywords = []

for permission in permissions:
    permission = permission.split(".")[-1]
    if permission in permissions_list:
        found_permissions.append(permission)
    
for permission in permissions_list:
    if permission in found_permissions:
        test_df[permission] = 1
    else:
        test_df[permission] = 0
        
test_df.head()

for method in d.get_methods():
    for api_call in api_call_signatures:
        if re.search(api_call.encode(), method.get_descriptor()):  
            found_api_signatures.append(api_call)
            
for api_call in api_call_signatures:
    if api_call in found_api_signatures:
        test_df[api_call] = 1
    else:
        test_df[api_call] = 0
        
test_df.head()

for intent_filter in intent_filters:
    action_elements = intent_filter.findall(".//action")
    for action_element in action_elements:
        action_value = action_element.get("{http://schemas.android.com/apk/res/android}name").encode() 
        for intent in intents:
            if re.search(intent.encode(), action_value):
                found_intents.append(intent)
                
for intent in intents:
    if intent in found_intents:
        test_df[intent] = 1
    else:
        test_df[intent] = 0
        
test_df.head()

for method in d.get_methods():
    for keyword in keywords:
        try:
            if re.search(keyword.encode(), method.get_code().get_instruction()):
                found_keywords.append(keyword)
        except:
            pass
        
for keyword in keywords:
    if keyword in found_keywords:
        test_df[keyword] = 1
    else:
        test_df[keyword] = 0
        
test_df.head()

dropped = test_df.drop(columns=["class", "filename"], axis=1)
predictions = rf.predict(dropped)
print(predictions)